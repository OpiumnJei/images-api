
# =========================================================================
#  ETAPA 1: LA F√ÅBRICA üè≠ (Donde construimos la aplicaci√≥n)
# =========================================================================
# El objetivo aqu√≠ es convertir tu c√≥digo fuente en un archivo .jar ejecutable.
# Usamos herramientas pesadas que no queremos en el producto final.

# Paso 1: Elegir la maquinaria.
# Empezamos con una imagen de Docker que es como un taller completo: ya tiene
# instalado Java 17 y la herramienta de construcci√≥n Maven.
# Le ponemos la etiqueta "build" para poder referirnos a esta f√°brica m√°s tarde.
FROM maven:3.8-openjdk-17 AS build

# Paso 2: Designar la mesa de trabajo.
# Dentro de la f√°brica, creamos una carpeta llamada "/app". A partir de ahora,
# todos los trabajos se realizar√°n dentro de esta carpeta.
WORKDIR /app

# Paso 3: Traer la lista de materiales.
# Copiamos solo el archivo pom.xml. Este archivo es como la lista de todas
# las piezas de LEGO (dependencias) que nuestro proyecto necesita.
COPY pom.xml .

# Paso 4: Descargar todos los materiales.
# Le decimos a Maven que lea la lista (pom.xml) y descargue todas las piezas
# de internet. Hacemos esto ahora para que Docker pueda reutilizar estas
# piezas descargadas en futuras construcciones si la lista no cambia,
# haciendo todo mucho m√°s r√°pido. ‚ú®
RUN mvn dependency:go-offline

# Paso 5: Traer las instrucciones de ensamblaje.
# Ahora copiamos nuestro propio c√≥digo fuente (la carpeta "src") a la f√°brica.
COPY src ./src

# Paso 6: Fabricar el producto final.
# Le ordenamos a Maven que compile todo y lo empaquete en un √∫nico archivo
# ejecutable (.jar). Esto es como ensamblar todas las piezas de LEGO
# para formar el modelo final.
RUN mvn package -DskipTests


# =========================================================================
#  ETAPA 2: LA CAJA DEL PRODUCTO üè† (Donde ejecutamos la aplicaci√≥n)
# =========================================================================
# Ahora nos olvidamos de la f√°brica y sus herramientas. Empezamos con una
# caja limpia y ligera que solo contendr√° nuestra aplicaci√≥n terminada.

# Paso 7: Elegir la base para la caja.
# Empezamos de cero con una imagen s√∫per ligera que solo tiene lo m√≠nimo
# indispensable para ejecutar Java. No hay herramientas de construcci√≥n aqu√≠.
FROM eclipse-temurin:17-jre-alpine

# Paso 8: Preparar el espacio en la caja.
# Creamos una carpeta "/app" para colocar nuestra aplicaci√≥n terminada.
WORKDIR /app

# Paso 9: Crear usuario no-root para seguridad.
# En producci√≥n, nunca ejecutamos como root.
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

# Paso 10: Mover el producto de la f√°brica a la caja.
# Este es el paso clave. Copiamos el archivo .jar que creamos en la Etapa 1
# (la f√°brica "build") a nuestra caja final y le ponemos un nombre simple: "app.jar".
COPY --from=build /app/target/*.jar app.jar

# Paso 11: Ponerle una "etiqueta" al puerto.
# Le decimos a Docker que nuestra aplicaci√≥n, una vez encendida, escuchar√°
# peticiones en el puerto 8080. Es como indicar en la caja "conectar aqu√≠".
EXPOSE 8080

# Paso 12: Escribir las instrucciones de "encendido" optimizadas para contenedores.
# -XX:+UseContainerSupport: Detecta l√≠mites de memoria del contenedor
# -XX:MaxRAMPercentage=75: Usa m√°ximo 75% de la RAM disponible
# -Djava.security.egd: Mejora el rendimiento de generaci√≥n de n√∫meros aleatorios
ENTRYPOINT ["java", \
    "-XX:+UseContainerSupport", \
    "-XX:MaxRAMPercentage=75.0", \
    "-Djava.security.egd=file:/dev/./urandom", \
    "-jar", "app.jar"]
